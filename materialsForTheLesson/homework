https://javarush.com/groups/posts/3321-razbor-primera-deadlock
C:\Users\AIT TR Student\.jdks\openjdk-21.0.1\bin\jconsole
===============================================================================================================================
Task 1
Implement deadlock in accordance with the diagram from the presentation.

Задание 1
Реализовать взаимную блокировку (deadlock) в соответствии со схемой из презентации.

(см файл Threads_2...)
===============================================================================================================================
Итак, давайте попытаемся понять, что же происходит в приведённом коде, когда возникает взаимная
 блокировка потоков. Так называемый "DeadLock":
В первом потоке, создаётся новый объект класса DeadLock.
В ходе работы конструктора, он создаёт второй поток, передав создаваемому потоку ссылку на конструируемый объект.
Затем, в первом потоке, вызывается метод запуска второго потока. Второй поток начинает исполнять метод run(). Начинается гонка.
В первом потоке управление передаётся методу foo() объекта a. Этот метод автоматически захватывает монитор объекта a,
 а затем в ходе выполнения 12 строки переводит первый поток в спящее состояние на одну секунду.
  Монитор объекта a всё ещё захвачен.
В это время, второй поток передаёт управление методу bar() объекта b.
Монитор объекта b автоматически захватывается. В ходе выполнения 32 строки, второй поток засыпает на одну секунду.
Монитор объекта b остаётся захвачен.
Далее либо первый поток проснётся раньше второго, либо второй проснётся раньше первого, либо они проснуться одновременно.
Это не будет иметь никакого значения. Их судьба уже решена. Их ожидает взаимная блокировка.
Просыпается первый поток, и в ходе выполнения 18 строки, передаёт управление методу last() объекта b.
 Этот метод пытается автоматически захватить монитор объекта b, но терпит неудачу, поскольку монитор объекта b всё ещё захвачен
 вторым потоком, который выполняет метод bar() объекта b. Так как необходимый монитор захватить не удалось, первый поток
 переводится в спящее состояние, ожидая освобождения монитора объекта b.
Просыпается второй поток, и в ходе выполнения 38 строки, передаёт управление методу last() объекта a.
Этот метод пытается автоматически захватить монитор объекта a, но терпит неудачу, поскольку монитор объекта a
всё ещё захвачен первым потоком, который выполняет метод foo() объекта a. Так как необходимый монитор захватить не удалось,
 второй поток переводится в спящее состояние, ожидая освобождения монитора объекта a.
В данной ситуации совершенно неважно, какой из потоков проснётся раньше, а какой позже,
или они вообще проснуться одновременно. Результат всё равно один.
Каждый поток заснул, ожидая освобождения так необходимого монитора, другим потоком.
Но первый поток держит захваченным монитор объекта a, ожидая освобождения монитора объекта b,
а второй поток, держит в захвате монитор объекта b, ожидая освобождения монитора объекта a.
Гонка закончилась. Оба потока не могут продолжать выполнение. Взаимная блокировка. DeadLock.


Могут ли потоки, в ходе выполнения данного кода избежать взаимной блокировки?
Да, могут. Хотя это маловероятно. Для этого необходимо выполнение одного из следующих условий:
Либо первый поток просыпается, и в ходе выполнения метода last(), объекта b, успевает захватить монитор этого объекта,
прежде чем монитор упомянутого объекта будет захвачен вторым потоком во время исполнения метода bar().
Либо наоборот - второй поток просыпается, и в ходе выполнения метода last(), объекта a,
успевает захватить монитор этого объекта, прежде чем монитор упомянутого объекта будет захвачен первым потоком
 во время исполнения метода foo().
Если будет исполнено какое-либо из условий, то один поток свободно завершит выполнение метода last(),
 после чего другой поток так же, без проблем, продолжит своё исполнение. Но, как я упомянул ранее, это маловероятно,
 так как потоки, в начале, засыпают на целую секунду (вечность, с точки зрения процессора),
  а JVM запускает выполнение потоков очень быстро.
